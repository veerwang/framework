<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<meta http-equiv="Content-Language" content="zh-cn">
<title>使用SDL：线程</title>
</head>

<body bgcolor="#FFF8DC" text="#000000">
<TABLE>
<TR><!--#include file="../menu.tmpl" -->
<TD>

<p align="center">
[<a href="usingcdrom.html">前一页</a>]     
<a href="toc.html"><font color="#8B0000">目录</font> </a>
[<a href="usingtimers.html">下一页</a>]
</p>

<h1><font color="#8B0000">使用SDL</font></h1>

<h2>线程</h2>

<table border="0" cellpadding="4">
    <tr>
        <td valign="top"><ul>
            <li><strong>创建简单的线程</strong></li> 
        </ul>
        <blockquote>
            <p>把一个函数作为SDL_CreateThread()的参数就可以创建一个线程。如果调用成功，该函数就   
            开始并行运行了，使用自己的栈、寄存器等上下文（context），并能象程序其他部分一样访问内存和文件句柄。
	 </p>
        </blockquote>
        </td>
        <td valign="top" width="200" bgcolor="#D3D3D3"><strong>提示：</strong><br>
        SDL_CreateThread()的第二个参数将被传递给新线程。你可以传入一个放在栈上的值，也可以传入一个供线程使用的数据指针。</td> 
    </tr>
</table>

<table border="0" cellpadding="50">
    <tr>
        <td valign="top"><font color="#000080"><strong>例程：</strong></font><pre>
<font color="#0000FF">#include</font> &quot;<font color="#000000">SDL_thread.h</font>&quot;

<font color="#008000">int</font> global_data = 0;

<font color="#008000">int</font> thread_func(<font
color="#008000">void *</font>unused)
{
    <font color="#008000">int</font> last_value = 0;

    <font color="#0000FF">while</font> ( global_data != -1 ) {
        <font color="#0000FF">if</font> ( global_data != last_value ) {
            printf(&quot;数据改变为<font color="#000000"> %d\n</font>&quot;, global_data);
            last_value = global_data;
        }
        SDL_Delay(100);
    }
    printf(&quot;<font color="#000000">线程退出</font><font color="#000000">\n</font>&quot;);
    <font color="#0000FF">return</font>(0);
}

{
    SDL_Thread *thread;
    <font color="#008000">int</font> i;

    thread = SDL_CreateThread(thread_func, NULL);
    <font color="#0000FF">if</font> ( thread == NULL ) {
        fprintf(stderr, &quot;<font color="#000000">无法创建线程</font><font color="#000000">： %s\n</font>&quot;, SDL_GetError());
        return;
    }

    <font color="#0000FF">for</font> ( i=0; i&lt;5; ++i ) {
        printf(&quot;<font color="#000000">更改数据为</font><font color="#000000"> %d\n</font>&quot;, i);
        global_data = i;
        SDL_Delay(1000);
    }

    printf(&quot;<font color="#000000">通知线程退出</font><font color="#000000">\n</font>&quot;);
    global_data = -1;
    SDL_WaitThread(thread, NULL);
}
</pre>
        </td>
    </tr>
</table>

<table border="0" cellpadding="4">
    <tr>
        <td valign="top"><ul>
            <li><strong>对资源访问进行同步  </strong></li>
        </ul>
        <blockquote>
            <p>通过创建互斥体（mutex），并将资源用lock 
            (SDL_mutexP())和unlock (SDL_mutexV())保护起来，就可以防止多个线程同时访问该资源。</p> 
        </blockquote>
        </td>
        <td valign="top" width="200" bgcolor="#D3D3D3"><strong>提示：</strong><br>
        任何可能会被多个线程访问的数据都应该用mutex保护起来。</td>
    </tr>
</table>

<table border="0" cellpadding="50">
    <tr>
        <td valign="top"><font color="#000080"><strong>例程：</strong></font><pre>
<font color="#0000FF">#include</font> &quot;<font color="#000000">SDL_thread.h</font>&quot;
<font color="#0000FF">#include</font> &quot;<font color="#000000">SDL_mutex.h</font>&quot;

<font color="#008000">int</font> potty = 0;
<font color="#008000">int</font> gotta_go;

<font color="#008000">int</font> thread_func(<font
color="#008000">void *</font>data)
{
    SDL_mutex *lock = (SDL_mutex *)data;
    <font color="#008000">int</font> times_went;

    times_went = 0;
    <font color="#0000FF">while</font> ( gotta_go ) {
        SDL_mutexP(lock);    <font color="#FF0000">/* 锁住potty */</font>
        ++potty;
        printf(&quot;<font color="#000000">线程</font><font color="#000000">%d 正在使用potty\n</font>&quot;, SDL_ThreadID());
        <font color="#0000FF">if</font> ( potty &gt; 1 ) {
            printf(&quot;<font color="#000000">哦</font><font color="#000000">，有人在用potty!\n</font>&quot;);
        }
        --potty;
        SDL_mutexV(lock);
        ++times_went;
    }
    printf(&quot;好了<font color="#000000">\n</font>&quot;);
    <font color="#0000FF">return</font>(times_went);
}

{
    <font color="#0000FF">const</font> <font color="#008000">int</font> progeny = 5;
    SDL_Thread *kids[progeny];
    SDL_mutex  *lock;
    <font color="#008000">int</font> i, lots;

    <font color="#FF0000">/* 创建同步锁 */</font>
    lock = SDL_CreateMutex();

    gotta_go = 1;
    <font color="#0000FF">for</font> ( i=0; i&lt;progeny; ++i ) {
        kids[i] = SDL_CreateThread(thread_func, lock);
    }

    SDL_Delay(5*1000);
    SDL_mutexP(lock);
    printf(&quot;<font color="#000000">都完成了吗？\n</font>&quot;);
    gotta_go = 0;
    SDL_mutexV(lock);

    <font color="#0000FF">for</font> ( i=0; i&lt;progeny; ++i ) {
        SDL_WaitThread(kids[i], &amp;lots);
        printf(&quot;<font color="#000000">线程</font><font color="#000000"> %d 用过potty %d 次了\n</font>&quot;, i+1, lots);
    }
    SDL_DestroyMutex(lock);
}
</pre>
        </td>
    </tr>
</table>

<p align="center">
[<a href="usingcdrom.html">前一页</a>] 
<a href="toc.html"><font color="#8B0000">目录</font> </a>
[<a href="usingtimers.html">后一页</a>]
</p>

</TABLE>
</body>
</html>
